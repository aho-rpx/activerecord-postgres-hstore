{"name":"activerecord-postgres-hstore","tagline":"Goodbye serialize, hello hstore. Speed up hashes in the database.","google":"","body":"[![Build Status](https://secure.travis-ci.org/softa/activerecord-postgres-hstore.png?branch=master)](http://travis-ci.org/softa/activerecord-postgres-hstore)\r\n\r\nGoodbye serialize, hello hstore.\r\n--------------------------------\r\n\r\nYou need dynamic columns in your tables. What do you do?\r\n\r\n* Create lots of tables to handle it. Nice, now you’ll need more models and lots of additional sqls. Insertion and selection will be slow as hell.\r\n* Use a noSQL database just for this issue. Good luck.\r\n* Create a serialized column. Nice, insertion will be fine, and reading data from a record too. But, what if you have a condition in your select that includes serialized data? Yeah, regular expressions.\r\n\r\nRequirements\r\n------------\r\n\r\nPostgresql 8.4+ (also tested with 9.0) with contrib and Rails 3. (It\r\nmight work on 2.3.x with minor patches…)  \r\nOn Ubuntu, this is easy: `sudo apt-get install postgresql-contrib-9.0`\r\n\r\nOn Mac <del> …you are screwed. Use a VM.  </del> you should use [the binary package kindly provided by EnterpriseDB](http://www.enterprisedb.com/products-services-training/pgdownload#osx)  \r\n[Homebrew’s](https://github.com/mxcl/homebrew) Postgres installation also includes the contrib packages: `brew install postgres`\r\n\r\nNotes for Rails 3.1 and above\r\n-----------------------------\r\n\r\nThe master branch already support a custom serialization coder.  \r\nIf you want to use it just put in your Gemfile:\r\n\r\n    gem 'activerecord-postgres-hstore', git: 'git://github.com/softa/activerecord-postgres-hstore.git'\r\n\r\nIf you install them gem from the master branch you also have to insert a\r\nline in each model that uses hstore.  \r\nAssuming a model called **Person**, with a **data** field on it, the\r\ncode should look like:\r\n\r\n    class Person < ActiveRecord::Base\r\n      serialize :data, ActiveRecord::Coders::Hstore\r\n    end\r\n\r\nInstall\r\n-------\r\n\r\nHstore is a PostgreSQL contrib type, [check it out first](http://www.postgresql.org/docs/9.2/static/hstore.html).\r\n\r\nThen, just add this to your Gemfile:\r\n\r\n`gem 'activerecord-postgres-hstore'`\r\n\r\nAnd run your bundler:\r\n\r\n`bundle install`\r\n\r\nMake sure that you have the desired database, if not create it as the\r\ndesired user:\r\n\r\n`createdb hstorage_dev`\r\n\r\nAdd the parameters to your database.yml (these are system dependant),\r\ne.g.:\r\n\r\n    development:\r\n      adapter: postgresql\r\n      host: 127.0.0.1\r\n      database: hstorage_dev\r\n      encoding: unicode\r\n      username: postgres\r\n      password: \r\n      pool: 5\r\n\r\nNow you need to create a migration that adds hstore support for your\r\nPostgreSQL database:\r\n\r\n`rails g hstore:setup`\r\n\r\nRun it:\r\n\r\n`rake db:migrate`\r\n\r\nFinally you can create your own tables using hstore type. It’s easy:\r\n\r\n    rails g model Person name:string data:hstore\r\n    rake db:migrate\r\n\r\nYou’re done.  \r\nWell, not yet. Don’t forget to add indexes. Like this:\r\n\r\n`CREATE INDEX people_gist_data ON people USING GIST(data);`  \r\nor  \r\n`CREATE INDEX people_gin_data ON people USING GIN(data);`\r\n\r\nTo understand the difference between the two types of indexes take a\r\nlook at [PostgreSQL docs](http://www.postgresql.org/docs/9.2/static/textsearch-indexes.html).\r\n\r\nUsage\r\n-----\r\n\r\nOnce you have it installed, you just need to learn a little bit of new\r\nsqls for selecting stuff (creating and updating is transparent).  \r\nFind records that contains a key named 'foo’:\r\n\r\n    Person.where(\"data ? 'foo'\")\r\n\r\nFind records where 'foo’ is equal to 'bar’:\r\n\r\n    Person.where(\"data -> 'foo' = 'bar'\")\r\n\r\nThis same sql is at least twice as fast (using indexes) if you do it\r\nthat way:\r\n\r\n    Person.where(\"data > 'foo=>bar’\")\r\n  \r\nFind records where 'foo’ is not equal to 'bar’:\r\n  \r\n    Person.where(\"data -> 'foo' <> 'bar'\")\r\n\r\nFind records where 'foo’ is like 'bar’:\r\n\r\n    Person.where(\"data -> 'foo' LIKE '%bar%'\")\r\n\r\nIf you need to delete a key in a record, you can do it that way:\r\n\r\n    person.destroy_key(:data, :foo)\r\n\r\nThis way you’ll also save the record:\r\n\r\n    person.destroy_key!(:data, :foo)\r\n\r\nThe destroy\\_key method returns 'self’, so you can chain it:\r\n\r\n    person.destroy_key(:data, :foo).destroy_key(:data, :bar).save\r\n\r\nBut there is a shortcuts for that: \r\n\r\n   person.destroy_keys(:data, :foo, :bar)\r\n\r\nAnd finally, if you need to delete keys in many rows, you can:\r\n\r\n    Person.delete_key(:data, :foo)\r\n\r\nand with many keys:\r\n\r\n    Person.delete_keys(:data, :foo, :bar)\r\n\r\nHave fun.\r\n\r\nHelp\r\n----\r\n\r\nYou can use issues in github for that. Or else you can reach us at\r\ntwitter: [@dbiazus](https://twitter.com/#!/dbiazus) or [@joaomilho](https://twitter.com/#!/joaomilho)\r\n\r\nNote on Patches/Pull Requests\r\n-----------------------------\r\n\r\n* Fork the project.  \r\n* Make your feature addition or bug fix.  \r\n* Add tests for it. This is important so I don’t break it in a future version unintentionally.  \r\n* Commit, do not mess with rakefile, version, or history.  (if you want to have your own version, that is fine but bump version in a commit by itself I can ignore when I pull)  \r\n* Send me a pull request. Bonus points for topic branches.\r\n\r\nCopyright\r\n---------\r\n\r\nCopyright © 2010 Juan Maiz. See LICENSE for details.\r\n","note":"Don't delete this file! It's used internally to help with page regeneration."}